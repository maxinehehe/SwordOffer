# 二进制中的 1 个数

## 题目描述

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

## 解题的思路

> 如果一个整数不为0，那么这个整数至少有一位 是 1。比如 2 -> 0010
>
> 如果我们把这个整数减1，那么原来处在整数最右边的 ***1***  就会变为 0，原来在 1 后面的所有 0 都会变成 1（如果最右边的1 不是在最末尾，即 后面还有 0.）其余所有位不会受到影响。
>
> 举个栗子： 一个二进制数：1100， 从右边起第三位是处在最右边的 1， 减去 1 后， 第三位 变成 0， 他后面的两位 0 变成了 1， 而前面的1 保持不变， 因此得到的结果为 1011， 可以发现减 1 的结果 是把最右边的一个 1 开始所有的位都 取反了。 这个时候 如果我们再把原来的整数和减1之后的结果做 与 运算，会发现，从原来的整数最右边一个 1 那一位开始 所有位都会变成 0.
>
> 例如： 1100&1011 = 1000，也就是说，把一个整数减去 1，再和原整数做与运算，会把该整数最右边一个 1 变成 0， 那么 我们的解题思路就出来了， **一个整数的二进制有多少个1，就可以进行多少次这样的操作【n 和 n-1 做与运算】。**
>
> 因此可以构建 核心步骤：
>
> n = n & (n-1)
>
> 即 1100 & （1100-1） = 1000   那么 1000则作为下次运算中的 n 。 

## 拓展

> 使用 n & 1 可以判断 n 是否为 奇数，
>
> 因为  偶数 & 1 == 1,  奇数 & 1 == 0

# 代码实现（java）

```java
// 利用一个结论：
// 一个二进制数n减1后与原二进制数进行&运算( 即n&(n-1) )会消去最右边的1。
public class Solution {
    public int NumberOf1(int n) {
       int count = 0;
        while(n!=0){
            count++;
            n = n&(n-1);
        }
        return count;
    }
}
```

