# 数据流中的中位数

## 题目描述

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。

## 解题思路

```
这里使用最大堆和最小堆处理
对于 中位数 前后的数 使用不同的堆进行保存， 只需要翻转一个堆即可。
比如 1 2 3 【6】 7 8 9
6 是下一个将要插入的数据 那么 可以 将其前面的数 1 2 3用 最大堆保存 即  3 2 1  后面的数使用 最小堆保存 7 8 9.

 将中位数以后的数保存到 最小堆中 中位数以前的数保存到最大堆中
        然后 如果 给定的数进行判断是否要插入 对面的堆 如果是的 则进行插入对面的对
        然后取堆顶元素 插入到自身中【根据奇偶数计数进行判定】
        比如 1 2 3 中位数以前的使用最大堆保存 为 3 2 1 
        7 8 9 中位数以后的使用 最小堆保存 为 7 8 9
        设定 奇数计数插入最大堆 反之插入最小堆
        这样操作是为了方便后面进行对比 
        当奇数计数时 直接根据上面规则 取 最大堆的堆顶元素即可
        当偶数计数时直接使用 双堆的堆顶元素求平均数即可
        
 保证先从最大堆开始存起
 奇数存最大堆 偶数存最小堆 不过需要注意下面的情况
 
 这里有一个问题需要考虑 接上面的例子 
 如果给定一个数 4 且当前计数是奇数 这时正好放入最大堆 此时最大堆为 4 3 2 1     
 但是 如果此时 给定一个数 11 且计数是奇数 那么是否直接放入最大堆？
 此时 是不能直接放入最大堆的 因为在计算的时候 直接取最大堆的堆顶元素 就会是 
 11 然而此时中位数并不是 11 所以需要同时考虑此时的数是否大于最小堆（即中位数后面的数的最小值）
 的堆顶元素， 如果大于就需要先插入最小堆 然后再进行 取出最小堆的堆顶元素 赋值给num,
 再将num插入最小堆
             
这里做同样的判断 即此时计数为偶数 但来了个 0 不能直接放入
最大堆 需要判断 即 此数本应该放入 最大堆的 因此需要从最大堆借“数”
             
```

## 实现代码

```java
import java.util.PriorityQueue;
import java.util.Comparator;
public class Solution {
    // 使用最大堆和最小堆进行处理
    // java中堆的问题使用 优先队列进行处理
    // 堆的创建首先是 将序列进行排序 最大堆就是从大到小排序
    // 最小堆 是从小到大排序 默认是最小堆
    
     // 定义最小堆
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        // 定义最小堆
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(
        11, new Comparator<Integer>(){
            // 匿名构造函数
            // 重写 比较函数
            public int compare(Integer t1, Integer t2){
                return t2.compareTo(t1);
                // 默认是 t1.compareTo(t2); 这里采用倒排序
                // 如果 t2 > t1 返回一个大于0的值
                // 如果 t2 == t1 返回 0
                // 如果 t2 < t1 返回 小于0的值
            }
        });
    private int count = 0;
    public void Insert(Integer num) {
        // 插入的思路
        /*
        将中位数以后的数保存到 最小堆中 中位数以前的数保存到最大堆中
        然后 如果 给定的数进行判断是否要插入 对面的堆 如果是的 则进行插入对面的对
        然后取堆顶元素 插入到自身中【根据奇偶数计数进行判定】
        比如 1 2 3 中位数以前的使用最大堆保存 为 3 2 1 
        7 8 9 中位数以后的使用 最小堆保存 为 7 8 9
        设定 奇数计数插入最大堆 反之插入最小堆
        这样操作是为了方便后面进行对比 
        当奇数计数时 直接根据上面规则 取 最大堆的堆顶元素即可
        当偶数计数时直接使用 双堆的堆顶元素求平均数即可
        */
        count++; // 保证先从最大堆开始存起
        // int tmp; // 不放在判断中创建 放置频繁的GC
         if((count&1) == 1){ // 奇数 放入最大堆
             /*
             这里有一个问题需要考虑 接上面的例子 
             如果给定一个数 4 且当前计数是奇数 这时正好放入最大堆 此时最大堆为 4 3 2 1     
             但是 如果此时 给定一个数 11 且计数是奇数 那么是否直接放入最大堆？
             此时 是不能直接放入最大堆的 因为在计算的时候 直接取最大堆的堆顶元素 就会是 
             11 然而此时中位数并不是 11 所以需要同时考虑此时的数是否大于最小堆（即中位数后面的数的最小值）
             的堆顶元素， 如果大于就需要先插入最小堆 然后再进行 取出最小堆的堆顶元素 赋值给num,
             再将num插入最小堆
             */
             if(!minHeap.isEmpty()&& num > minHeap.peek()){ // 这里判断 最小堆是否为空以及最小堆
                 minHeap.offer(num);
                 num = minHeap.poll(); 
                 // 注意 poll()是直接取出元素 peek()是取堆顶元素 但不删除
             }
             maxHeap.offer(num);
         }else{ // 否则放入最小堆
             // 这里做同样的判断 即此时计数为偶数 但来了个 0 不能直接放入
             // 最大堆 需要判断 即 此数本应该放入 最大堆的 因此需要从最大堆借“数”
             if(num < maxHeap.peek()){
                 maxHeap.offer(num);
                 num = maxHeap.poll();  // 这里写错 将 maxHeap写成minHeap 该罚
             }
             minHeap.offer(num);
         }
    }

    public Double GetMedian() {
        if(count == 0){
            return null;
        }
        if((count&1)==1){ // 等价于 count%2 == 1 判断是否为奇数
            return (double)maxHeap.peek(); // 不需要用poll() 取出没必要
        }else{
            return (double)(minHeap.peek()+maxHeap.peek())/2;
        }
    }
}
```

